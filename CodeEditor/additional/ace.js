// Generated by CoffeeScript 1.6.2
(function() {
  var Range, applyToShareJS, requireImpl, curEditor, markers = {};

  requireImpl = ace.require != null ? ace.require : require;

  Range = requireImpl("ace/range").Range;

  updateMarkers = function(pos, user, action, text) {
    $.each(markers, function(a, b) {
      if (a != user && markers[a]["posx"] >= pos.row) {
        curEditor.session.removeMarker(markers[a]["pointer"]);
        if (action == "insert") markers[a]["posx"]++;
        else if (action == "delete") markers[a]["posx"]--;
        markers[a]["pointer"] = curEditor.session.addMarker(new Range(markers[a]["posx"], markers[a]["posy"] + 1, markers[a]["posx"], markers[a]["posy"] + 2), a.replace(" ", "_") + " cursorPointer", true);
      }
    })
  };

  updateOtherCursors = function(pos, user, action, text) {
		var Range = ace.require('ace/range').Range;
    if (markers[user] != undefined || markers[user] != null)
      curEditor.session.removeMarker(markers[user]["pointer"]);
    if (text == '\n') {
      if (action == "insert")
        pos.row++;
      updateMarkers(pos, user, action, text);
    }
		markers[user] = {
      pointer: curEditor.session.addMarker(new Range(pos.row, pos.column + 1, pos.row, pos.column + 2), user.replace(" ", "_") + " cursorPointer", true),
      posx: pos.row,
      posy: pos.column
    }
  };

  applyToShareJS = function(editorDoc, delta, doc, username) {
    var getStartOffsetPosition, pos, text;

    getStartOffsetPosition = function(range) {
      var i, line, lines, offset, _i, _len;

      lines = editorDoc.getLines(0, range.start.row);
      offset = 0;
      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
        line = lines[i];
        offset += i < range.start.row ? line.length : range.start.column;
      }
      return offset + range.start.row;
    };
    pos = getStartOffsetPosition(delta.range);
    switch (delta.action) {
      case 'insertText':
        if (delta.text == '\n')
          updateMarkers(delta.range.end, username, "insert", delta.text);
        doc.insert(username, pos, delta.text);
        break;
      case 'removeText':
        if (delta.text == '\n')
          updateMarkers(delta.range.end, username, "delete", delta.text);
        doc.del(username, pos, delta.text.length);
        break;
      case 'insertLines':
        text = delta.lines.join('\n') + '\n';
        doc.insert(username, pos, text);
        break;
      case 'removeLines':
        text = delta.lines.join('\n') + '\n';
        doc.del(username, pos, text.length);
        break;
      default:
        throw new Error("unknown action: " + delta.action);
    }
  };

  window.sharejs.extendDoc('attach_ace', function(user, editor, keepEditorContents) {
    var check, deleteListener, doc, docListener, editorDoc, editorListener, insertListener, offsetToPos, refreshListener, replaceTokenizer, suppress;
    if (!this.provides['text']) {
      throw new Error('Only text documents can be attached to ace');
    }
    doc = this;
    curEditor = editor;
    editorDoc = editor.getSession().getDocument();
    editorDoc.setNewLineMode('unix');
    check = function() {
      return window.setTimeout(function() {
        var editorText, otText;

        editorText = editorDoc.getValue();
        otText = doc.getText();
        if (editorText !== otText) {
          console.error("Text does not match!");
          console.error("editor: " + editorText);
          return console.error("ot:     " + otText);
        }
      }, 0);
    };
    if (keepEditorContents) {
      doc.del(0, doc.getText().length);
      doc.insert(0, editorDoc.getValue());
    } else {
      editorDoc.setValue(doc.getText());
    }
    check();
    suppress = false;
    editorListener = function(change) {
      if (suppress) {
        return;
      }
      applyToShareJS(editorDoc, change.data, doc, user);
      return check();
    };
    replaceTokenizer = function() {
      var oldGetLineTokens, oldTokenizer;

      oldTokenizer = editor.getSession().getMode().getTokenizer();
      oldGetLineTokens = oldTokenizer.getLineTokens;
      return oldTokenizer.getLineTokens = function(line, state) {
        var cIter, docTokens, modeTokens;

        if ((state == null) || typeof state === "string") {
          cIter = doc.createIterator(0);
          state = {
            modeState: state
          };
        } else {
          cIter = doc.cloneIterator(state.iter);
          doc.consumeIterator(cIter, 1);
        }
        modeTokens = oldGetLineTokens.apply(oldTokenizer, [line, state.modeState]);
        docTokens = doc.consumeIterator(cIter, line.length);
        if (docTokens.text !== line) {
          return modeTokens;
        }
        return {
          tokens: doc.mergeTokens(docTokens, modeTokens.tokens),
          state: {
            modeState: modeTokens.state,
            iter: doc.cloneIterator(cIter)
          }
        };
      };
    };
    if (doc.getAttributes != null) {
      replaceTokenizer();
    }
    editorDoc.on('change', editorListener);
    docListener = function(op) {
      suppress = true;
      applyToDoc(editorDoc, op);
      suppress = false;
      return check();
    };
    offsetToPos = function(offset) {
      var line, lines, row, _i, _len;

      lines = editorDoc.getAllLines();
      row = 0;
      for (row = _i = 0, _len = lines.length; _i < _len; row = ++_i) {
        line = lines[row];
        if (offset <= line.length) {
          break;
        }
        offset -= lines[row].length + 1;
      }
      return {
        row: row,
        column: offset
      };
    };
    doc.on('insert', insertListener = function(user, pos, text) {
      suppress = true;
      var newpos = offsetToPos(pos);
      editorDoc.insert(newpos, text);
      updateOtherCursors(newpos, user, "insert", text);
      suppress = false;
      return check();
    });
    doc.on('delete', deleteListener = function(user, pos, text) {
      var range;
      suppress = true;
      var newpos = offsetToPos(pos);
      range = Range.fromPoints(newpos, offsetToPos(pos + text.length));
      updateOtherCursors(newpos, user, "delete", text);
      editorDoc.remove(range);
      suppress = false;
      return check();
    });
    doc.on('refresh', refreshListener = function(startoffset, length) {
      var range;

      range = Range.fromPoints(offsetToPos(startoffset), offsetToPos(startoffset + length));
      return editor.getSession().bgTokenizer.start(range.start.row);
    });
    doc.detach_ace = function() {
      doc.removeListener('insert', insertListener);
      doc.removeListener('delete', deleteListener);
      doc.removeListener('remoteop', docListener);
      doc.removeListener('refresh', refreshListener);
      editorDoc.removeListener('change', editorListener);
      return delete doc.detach_ace;
    };
  });

}).call(this);
